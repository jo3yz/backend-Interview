## 前提
首先需要明确的epoll系列的syscall都是线程安全的，内部用的自旋锁

## 惊群问题
epoll虽然好用，但是存在一个问题，即如果多个进程（线程）陷入epoll_wait，回调的时候将会唤醒所有epollevent上面的进程，想象一个很常见的场景：在一个多核机器上（假设是32核），有多个进程在同时等待tcp的accept事件，这时候一个连接起来，网络栈将会唤醒所有在这个socket上监听的进程，但是只会有一个进程是accept成功的，其他进程失败之后再次进入睡眠，如果是在一个qps特别高的业务中，一个连接进来就会唤醒一大片进程，这就是惊群问题，他严重影响性能

## 解决方案
1. 在4.5内核中，linux已经触发了这个问题，他为epoll增加了一个EPOLLEXCLUSIVE标志位，增加了这个选项之后，内核每次只会唤醒一个进程，其实在内核里面的实现也非常简单，就是在文件poll的唤醒中进行了互斥进程的唤醒，如果唤醒的第一个进程被调协了EPOLLEXCLUSIVE标志，则唤醒之后马上退出，但是这接着会带来负载不平衡的问题，关于这个问题后面我再更新，目前还没有仔细研究
2. 每个线程一个epoll
