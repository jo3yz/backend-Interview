## 如何拿到glibc里面的原版socket api
先回答为什么需要拿：我们的hook版本的api必须要通过原版的api来实现
```
g_sys_socket_func = (socket_pfun_t)dlsym(RTLD_NEXT, "socket");
```
这个函数调用的作用是从当前库之后load进来的库中寻找socket这个符号（当然是找glibc里面的socket啦）

## 如何保证库本身和其他第三方库调用的是自己实现的socket api
就是通过调整最终生成的可执行文件的链接顺序，使其全局符号表中的跟socket相关函数的符号为libco协程库中的符号。那么链接过程中会发生什么？

在链接过程中，链接器会按顺序扫描输入的目标文件，将其中的符号合并到全局符号表中，当一个符号需要加入全局符号表时，如果相同的符号名已经存在，则后面加入的符号被忽略。

## 为什么要使用extern "C" {}
因为C++为了支持函数重载等特性，在编译阶段会将函数名字做魔改，加上这个符号，就等于告诉编译器，让它以C的方式来处理括号中括着的函数，只有这样，glibc在连接时，才会因为有同名符号而将其socket api给忽略掉。

## 注意
因为hook机制依赖链接的顺序，所以在链接时，一定要保证将 ```-llibelaine``` 放在最前面。