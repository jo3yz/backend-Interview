## 为什么不能滥用timerfd
要集成在事件循环里，使用很多个timerfd肯定是不行的，如果定时任务多，那epoll需要维护的fd就太多了。epoll中所有需要监听的fd都被组织到红黑树上。epoll对socket的监听应该是通过注册网卡中断的回调来完成的，当网卡中断来临时，将这个节点插入到就绪队列上。红黑树如果上面挂的东西太多，查询的开销也会增大的。

## 解决方案
- 可以使用一个有序的容器来在用户态组织定时器，比如map<Timestamp, Timer::Ptr>。这样的话就可以使得整个系统中只需要维护一个timerfd就好了，只需要让epoll_wait返回timerfd的时候，找到容器中已经过期的定时器的回调或者协程，再将他们加入到执行队列里。这样会对定时器精度有所牺牲（但是很小）。
- 注意为什么这里是要处理的是过期的定时器呢？因为这样的方案是做不到准时执行的，在epoll_wait返回后拿到的timer一定都是已经过期的，退一万步说就算刚刚好到点没过期，epoll_wait拿到的fd又不只是timerfd，可能还有socketfd，要把对应的协程运行完之后，这下定时器总该过期了吧。
- 处理完过期的定时器后，需要把最近未过期的定时器设置为timerfd的过期时间，再加入epoll

## 一些设计的考量
- 使用什么容器来组织定时器呢？这个容器需要有序，因为需要根据epoll_wait返回时的时间戳来将容器中key小于当前时间的定时器都取出来。容易想到的应该是map和优先队列。
- 但是key的重复可能是个问题，因为不能保证每个定时器的到期时间都不一样。所以可以考虑如果重叠了，就将其中一个微调一下。或者直接使用multimap