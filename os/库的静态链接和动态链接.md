## 什么是库？
库是用来一些编译模块（可重定位目标文件）的集合，可执行程序在链接它后，可以访问其外部符号变量或者执行其外部符号函数

## 库起什么作用？
分离编译，降低编译成本

## 库的三种加载方式
1. 链接器：静态链接，将所有相关的目标模块（包含glibc这样的基础模块），都打包到可执行文件中。静态库中包含的所有可重定位目标只在被实际的程序引用时，链接器才会把它和与它相关的可重定位目标复制进可执行文件的内存。这样可能可执行文件很大，但是占用内存小。

2. 链接器：动态连接，在使用动态链接时，需要在程序映象中每个调用库函数的地方打一个桩（stub）。stub是一小段代码，用于定位已装入内存的相应的库；如果所需的库还不在内存中，stub将指出如何将该函数所在的库装入内存。当执行到这样一个stub时，首先检查所需的函数是否已位于内存中。如果所需函数尚不在内存中，则首先需要将其装入。不论怎样，stub最终将被调用函数的地址替换掉。这样，在下次运行同一个代码段时，同样的库函数就能直接得以运行，从而省掉了动态链接的额外开销。由此，用到同一个库的所有进程在运行时使用的都是这个库的同一份拷贝。

3. 运行时：从应用程序中加载，灵活性比较好，dlopen/dlsym/dlclose等函数

## 静态库加载时需要注意的问题
定义一个符号的库，必须在使用这个符号的目标文件之后出现，如果库之间相互依赖，可能在gcc输入库的命令行中，库的名字还会重复出现。