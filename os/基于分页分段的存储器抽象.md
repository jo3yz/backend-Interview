## 存储器抽象的目的
解决虚拟内存比物理内存更大的实际需求

## 空闲内存管理
1. 位图，查找连续内存块效率低，所以不用
2. 空闲内存块的双向链表

## 分段的作用
在早期（8086），分段是为了解决16位寄存器寻址20位总线的问题，在32位机上，是为了给每个进程划分单独的运行环境（代码段、堆栈段等），不同进程的段是通过LDT表存储的，每个进程对应一个LDT

## 为什么有了分段还要分页
0. 如果只使用分段，那么程序就必须全部被加载进内存才能执行，造成内存碎片后，无法充分利用内存，只能整体将进程内存换入换出
1. 每个程序拥有自己的地址空间，这个空间被分割成很多块，每个块称为一页（page），每个进程都需要有自己的页表，用于对应虚拟内存和物理内存
2. 每个页都对应一块连续的物理地址内存（8k），映射由硬件和软件共同完成（？）
3. 页不用完全加载也可以运行程序

## 页的引用和对换
1. 如果使用到一部分在内存中没有对应的页面时，就会引发缺页中断，陷入内核，把需要的页换进来
2. 当换入新页的时候，需要把稍老一些的页丢弃（如果是干净的）或者写入磁盘（如果已经写入过了）

## 如何加速分页过程
1. TLB（快表），利用了程序的局部性原理
2. 从快到慢：TLB->页表->陷入内核换页

## 三种地址
逻辑地址（程序中直接可以访问的虚拟内存） -> 线性地址（段描述符+偏移） -> 物理地址（访问页表或者TLB得到的地址）

## x86_64架构与x86的异同
x86_64架构的虚拟内存实际上只使用低48位，分别作为四级页表索引（4*9=36）和页内偏移（12位=4K），所以x86_64架构的页大小是4K，且虚拟地址和物理地址实际上只使用了低48位
x86使用了两级页表