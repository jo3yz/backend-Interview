## 啥是分布式锁？
可以理解为分布式的原子操作，当某个client要读取或写入某个值的时候，发现这个值已经被“占用”了，就只能放弃或者稍后再试。

## 最重要的基础
所有Redis的指令，都是原子的

## 使用Redis实现
- 使用setnx(set if not exists)指令，作用是当key不存在的时候，将key设置为value，key如果存在，就不做任何动作并返回
```
setnx lock:test true
// critical
del lock:test
```

## 问题来了
如果还没到del，程序就崩了咋办，这样就死锁了，又没有RAII能用。紧急补救方案：在setnx后加一个过期时间

## 问题又来了
万一设定过期时间也失败了怎么办，本质上这个错误是：setnx和设定过期时间是两条指令，而不是一条原子指令。解决方案：现在版本的Redis可以让这两个操作一起执行，成为一条原子指令

## 问题又又来了
如果持有锁的时间过长，以至于锁都过期了怎么办？首先，就不要做长时间的操作，此外可以为每个锁设定一个随机数，释放锁的时候要匹配才行

## 问题又又又来了
如果竞争锁失败，应该什么时候再竞争下一次锁呢？这可不像在单机OS中可以用睡眠锁。难不成只能使用polling+延迟队列的方式周期性的重试了？