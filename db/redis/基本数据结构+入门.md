## 五种最基本的数据结构
- 字符串string
- 列表list
- 集合set
- 哈希hash
- 有序集合zset

## 基础
Redis中所有的数据结构都有唯一Key，通过这个Key来访问数据，Key都是一样的类型，只是Value的结构可能不一样。
此外Key还可以设置过期时间，到点自动删除。


## string
1. 动态字符串，capacity一般大于size。扩容策略是：
- 小于1M，每次翻倍
- 大于1M，每次1M
2. 里面可以装数字，可以用incr/decr来加减

## list
- 简单来说，是双向链表，l/r+pop/push都可以，但是lindex是O(n)，要慎用。此外ltrim(start, end)是用来截取链表的，负数表示倒数，O(n)慎用。
- 实际上底层并不是个简单的链表，是称之为快速链表的结构。在元素较少的时候使用连续的内存存储（ziplist），数据量多了起来后才改成链表结构。原因有二：数量少的时候链表的指针成本比较明显，并且链表本就对cache不友好。实际的实现应该是ziplist+linklist

## hash
- 处理碰撞：拉链法
- 需要rehash的原因：负载因子太大，时间复杂度退化
- 渐进式rehash的原因：高性能服务不能容忍大规模rehash时的阻塞
- 渐进式rehash怎么做：保留两个hash的结构，查询的时候同时查询两边，在定时任务和对这个hash的指令中，将旧的hash内容一点点迁移到新的hash中去
- 序列化类到hash中，所需内存成本要比序列化到string更高，但是取的时候可以选择只取某个属性
- 最后一个元素被移除后，自动回收内存

## set
- 基于hash的无重复元素的集合（其实就是一个特殊的hash，所有value都是空）
- 最后一个元素被移除后，自动回收内存

## zset
- 非常有特色，一方面是一个set，保证val的唯一性，一方面每个val对应一个score，内部他是有序的
- 最后一个元素被移除后，自动回收内存
- 基于跳跃表，所以支持随机插入，每个元素的都有L0的指针，能有L1指针的概率是50%，L2指针的概率是25%，以此类推
- 跳跃表的查询、插入渐进复杂度和平衡二叉树一样

## 容器型数据结构的通用规则
1. create if not exists，比如rpush一个不存在的key，就在这个key上创建一个list
2. drop if no element， 字面意思
3. 所有的数据结构都可以设置过期时间，时间到了就删除整个对象（而不是hash对象的某个key），当然如果设置了过期时间后，再调用set去修改的话，过期时间会失效
