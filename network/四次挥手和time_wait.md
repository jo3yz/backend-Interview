## 握手/挥手的基础
握手包SYN和挥手包FIN都是**可靠**传输，如果传输出现了差错，会基于TCP的各种机制（重传等）保证其可靠性。任意一方的任意一次分节传输失败，都会重传。

## 为什么挥手要四次而不是三次？
一对挥手我认为是发送和接收方协商关闭了连接的“半部”（shutdown函数）。四次挥手，每次都是有用的。

第一次挥手

主动关闭方告诉被动关闭方：这个连接的这个方向我不写了，注意这个带FIN的包还带有上一个请求的ack。

第二次挥手

被动关闭方此时可能还有一些接收的数据未处理，不能立刻关闭连接，就回一个ack，告诉主动关闭方：好我知道了，等等我。我好了会通知你。此时从逻辑上来说，连接已经关闭了半部。**此时被动关闭方进入CLOSE_WAIT状态**

第三次挥手

被动关闭方现在做好了关闭另外一个半部的准备，向主动关闭方发带FIN的包，告诉主动关闭方：现在我来关我的半部了

第四次挥手

主动关闭方如果收到了被动关闭方发的FIN分节，就发送确认ack给被动关闭方，被动关闭方得到了反馈，安心的close掉了。**在发送ack之后，主动关闭方立刻进入TIME_WAIT状态**，时长为2MSL，在这段时间内，主动方的端口无法再次bind。如果主动方是客户端，再启动时会另觅端口。

## TIME_WAIT的作用
首先一定要记住，TIME_WAIT状态只有主动关闭方才会出现！

设计TIME_WAIT的主要原因是：主动关闭方没有其他办法保证第四次挥手的成功，只能靠等待重传FIN，如果在2MSL后都还等不到，就认为第四次挥手成功了。为什么呢？因为只要连接可达对端，那么所有分节都一定能在MSL能跑单边，2MSL内就一定能保证能echo回来。

它的主要作用有两个。
1. 因为无法保证第四次挥手一定不会出差错，所以要留一个窗口期，让被动关闭方重新进行第三次挥手。主要额外注意的是，被动方重新进行第三次挥手后，主动关闭方再次第四次挥手，发送ack时，TIME_WAIT的长度会重置为2MSL。原因很容易想通，不这样做的话，万一这次挥手又失败了怎么办？
2. 防止主动关闭方的“影分身”接收到了本应发送给已经消失的本体的信息。假设主动关闭防四次挥手后立刻关闭，但是此次挥手失败了，新的服务却又在这个端口上起起来了，可能还会收到被动关闭方的FIN分节。

## 为什么TIME_WAIT是2MSL
MSL是指maximum segement liftime，2MSL就是指他的两倍了。发送ack后等待2MSL保证了假如第三次挥手失败，一定可以收到被动关闭方的重传FIN。因为主动关闭方和被动关闭方单边的最长路程一定在2MSL内可以走完，如果2MSL内还没收到重传的FIN，就可以认为被动方已经成功关闭了。

## 如何优雅的处理TIME_WAIT
1. 服务端打开keep-alive，让客户端主动去关闭连接，反正谁主动关谁TIME_WAIT呗
2. 开启（net.ipv4.tcp_tw_reuse）端口复用和（net.ipv4.tcp_timestamps）TCP时间戳，前者依赖后者。开启了TCP时间戳选项后，任意一个TCP数据包都会包含发送它时的时间和最近一次接收到它的时间，如果“影分身”发现来的数据包已经是前任的了（通过时间戳判断），就直接丢弃