## 修饰非指针变量
1. const成员变量，无法被成员函数修改
2. const类实例（引用）只能调用const类型的函数，所指向的对象无法被修改（另外引用提供了无法被重新指向对象的保证）

## 修饰指针
1. const在前，效果和const引用一样，所指向的对象无法被修改
```
    const std::string *cp1(&cstr);
    std::string const *cp2(&cstr); // 这两种方式貌似等价
    
    cp1->clear(); // 编译错误，clear不是const成员函数
    cp2->clear(); // 编译错误，clear不是const成员函数
```
2. const在后，保证指针无法被重新指向，即指针值无法修改
```
    std::string * const pc(&cstr);
    pc = new std::string(""); // 编译错误，指针内容无法修改
```

## 修饰函数
1. const成员函数必须要提供不修改成员函数的保证，所以它不能修改成员变量。并且只能调用：
 - 同为const的成员函数
 - static成员函数（因为static成员函数无法修改成员变量）

## 修饰函数参数
1. **传入const类型的引用**，最常用&好用的惯用法，达到拷贝的效果（无法对源头造成影响，因为只能调用const成员函数），并且避免了无谓的拷贝
2. 传入const类型的拷贝，拷贝了一份，然后还不让对这个拷贝做修改（有病？？）
3. 传入const类型的指针（两种），效果见修饰指针

## 修饰返回值
1. 返回const拷贝，和传入const拷贝一样，是一个很迷的操作。
2. 返回const引用，效果和修饰变量一样，不能返回局部变量引用
3. 返回const指针，效果和修饰变量一样，不能反悔局部变量指针