## for range loop原理
实际上是基于迭代器的的语法糖

## 细节
1. for range loop用auto捕获到的是容器的value_type，比如map捕获到的就是pair<const T, U>，set捕获到的就是const T
2. for range冒号后面的表达式只会被执行一次
3. 如果在迭代中修改容器，导致迭代器失效的话，for range loop会崩（因为这东西实际上就是基于迭代器的）

## 如何让它支持自定义类型？
- 内建支持的是POD的数组（begin就是数组的首地址）和STL容器（会试图查找它的begin()和end()方法来定位迭代器）
- 如果都不支持，就尝试使用全局的begin()和end()来定位迭代器
- for range迭代过程中，对迭代器中使用分为：
    1. 取得begin()和end()，所以自定义类型要有这两个方法，来返回相应的迭代器
    2. 循环结束条件为iter != end()，所以不需要重载迭代器的<和>比较符，重载!=运算符即可
    3. 每次循环中迭代器的移动采用前置++，所以迭代器要提供这个方法
    4. 每次循环中，要捕获迭代器对应的值，所以还需要重载*运算符（解引用运算符）