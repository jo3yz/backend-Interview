## 为什么需要
1. 因为不是每一个硬件平台都可以随意访问任意地址的内存的
2. CPU会设计为一个周期内能连续读取4/8个字节的数据，4/8字节本可以一次读完，如果对齐不合理的话，就可能需要两次

## 自然对齐
- 比如一个int的大小是4字节，那么它的字节对齐也是4
- 字节对齐是4意味着int变量的内存地址必须是4个倍数

## 结构体对齐规则
- 让每个成员都能放在其**自然对齐**的位置
- 结构体的字节对齐应该是其内部最大成员的字节长度（也就是说，最后插入的padding大小，需要保证结构体的最终大小是最大元素大小的整数倍）
- 结构体对齐的值应该是最大成员大小的原因：结构体内元素的偏移可能随着结构体的起始地址而变化

## 结构体对齐举例（假设结构体起始地址为0x00）
对齐前：
```
struct {
    char a; // 0~1
    int b; // 1~5
    short c; // 5~7
    long long d; // 7~15
    char e; // 15~16
};
```

对齐后：
```
struct {
    char a; // 0~1
    char padding_0[3];
    int b; // 4~8
    short c; // 12~14
    char padding_1[2];
    long long d; // 16~24
    char e; // 24~25
    char padding_2[7];
};
```
可以发现对齐后保证了两个事情：
1. 每个元素自然对齐
2. 结构体以最大元素long long的8字节对齐（因为起始地址为0的话，这样结构体数组也是对齐的了）

## 堆内存有对齐
malloc得到的内存，一般是按照8/16位对齐。如果超出了这个范围可以使用平台相关的函数来实现。