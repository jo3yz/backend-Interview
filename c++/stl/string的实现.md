## 共性
无论是哪种实现，string的成员变量都必须保存char *（字符串本身）， size（字符串长度）和capacity（字符串容量）

## Eager Copy
实现起来和vector<char>差不多，拷贝语义，成员变量为三个指针，start/finish/end_of_storage

## COW（copy on write）
带引用计数，字符串的size/capaciy/refcount/data（数据指针）都保存在堆上，而string对象本身只保存这样一个地址。但是这样的实现对**多线程不友好**，为了保证多线程同时操作一块内存的线程安全，必须加锁，这会造成性能瓶颈。
写时拷贝是指当某个副本要进行字符串的写操作时，才着手拷贝一份真正的副本。
实际上基于COW技术的string也会在某些读的情况下产生拷贝动作，比如：
1. operator[]，因为用户可能使用```&str[0]```来获取内部数据的地址，后续是否进行写操作string是无法感知的，所以在要求副本的时候，就只能拷贝一份了。否则就会出现动一处，N处被修改的情况。
2. 获取迭代器，这不用说了吧
所以如果不需要对string内部进行修改，就不需要通过operator[]获取字符串内部地址或者引用，当然如果通过push_back等函数让迭代器或引用失效了，COW就又生效了。

## SSO（short string optimization）
我自己使用的GCC 9就是使用的这种实现，内部使用一个union复用本地buffer和capacity的空间（因为两者的存在是互斥的）。在字符串比较短的时候（16字节以下），就直接存在string的成员变量中。字符超过这个长度的话，就把字符串分配在堆上，又使用Eager Copy策略。我猜新标准关闭COW是因为对多线程不友好？